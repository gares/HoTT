<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>pSusp.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.14.0+0.14.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Basics.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Types.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Pointed.Core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Pointed.Loops.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Pointed.pMap.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Pointed.pHomotopy.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Pointed.pTrunc.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Pointed.pEquiv.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Homotopy.Suspension.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Homotopy.Freudenthal.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Truncations.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> WildCat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Generalizable Variables</span> <span class="nf">X</span> A B f g n.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> pointed_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Pointedness of [Susp] and path spaces thereof *)</span>
<span class="sd">(** We arbitrarily choose [North] to be the point. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ispointed_susp</span> {<span class="nv">X</span> : <span class="kt">Type</span>} : IsPointed (Susp X) | <span class="mi">0</span>
  := North.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ispointed_path_susp</span> `{IsPointed X}
  : IsPointed (North = South :&gt; Susp X) | <span class="mi">0</span> := merid (point X).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ispointed_path_susp&#39;</span> `{IsPointed X}
  : IsPointed (South = North :&gt; Susp X) | <span class="mi">0</span> := (merid (point X))^.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">psusp</span> (<span class="nv">X</span> : pType) : pType
  := Build_pType (Susp X) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Suspension Functor *)</span>

<span class="sd">(** [psusp] has a functorial action. *)</span>
<span class="sd">(** TODO: make this a displayed functor *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">is0functor_psusp</span> : Is0Functor psusp
  := Build_Is0Functor _ _ _ _ psusp (<span class="kr">fun</span> <span class="nv">X</span> <span class="nv">Y</span> <span class="nv">f</span>
      =&gt; Build_pMap (psusp X) (psusp Y) (functor_susp f) <span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** [psusp] is a 1-functor. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk0"><span class="highlight"><span class="kn">Instance</span> <span class="nf">is1functor_psusp</span> : Is1Functor psusp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Is1Functor psusp</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Is1Functor psusp</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2"><span class="highlight">snrapply Build_Is1Functor.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap psusp f $== fmap psusp g</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : pType, fmap psusp (Id a) $== Id (psusp a)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="psusp-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap psusp (g $o f) $== fmap psusp g $o fmap psusp f</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="sd">(** Action on 2-cells *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap psusp f $== fmap psusp g</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6"><span class="highlight"><span class="nb">intros</span> X Y f g p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X $-&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f $== g</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap psusp f $== fmap psusp g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7"><span class="highlight">pointed_reduce.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Build_pMap
  (psusp
     {| pointed_type := X; ispointed_type := point0 |})
  (psusp
     {|
       pointed_type := Y; ispointed_type := g point0
     |}) (functor_susp f) <span class="mi">1</span> ==*
Build_pMap
  (psusp
     {| pointed_type := X; ispointed_type := point0 |})
  (psusp
     {|
       pointed_type := Y; ispointed_type := g point0
     |}) (functor_susp g) <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8"><span class="highlight">srapply Build_pHomotopy.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Build_pMap
  (psusp
     {| pointed_type := X; ispointed_type := point0 |})
  (psusp
     {|
       pointed_type := Y; ispointed_type := g point0
     |}) (functor_susp f) <span class="mi">1</span> ==
Build_pMap
  (psusp
     {| pointed_type := X; ispointed_type := point0 |})
  (psusp
     {|
       pointed_type := Y; ispointed_type := g point0
     |}) (functor_susp g) <span class="mi">1</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk9"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?p</span>
  (point
     (psusp
        {|
          pointed_type := X; ispointed_type := point0
        |})) =
dpoint_eq
  (Build_pMap
     (psusp
        {|
          pointed_type := X; ispointed_type := point0
        |})
     (psusp
        {|
          pointed_type := Y;
          ispointed_type := g point0
        |}) (functor_susp f) <span class="mi">1</span>) @
(dpoint_eq
   (Build_pMap
      (psusp
         {|
           pointed_type := X; ispointed_type := point0
         |})
      (psusp
         {|
           pointed_type := Y;
           ispointed_type := g point0
         |}) (functor_susp g) <span class="mi">1</span>))^</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Build_pMap
  (psusp
     {| pointed_type := X; ispointed_type := point0 |})
  (psusp
     {|
       pointed_type := Y; ispointed_type := g point0
     |}) (functor_susp f) <span class="mi">1</span> ==
Build_pMap
  (psusp
     {| pointed_type := X; ispointed_type := point0 |})
  (psusp
     {|
       pointed_type := Y; ispointed_type := g point0
     |}) (functor_susp g) <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chkb"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_susp f == functor_susp g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chkc"><span class="highlight">srapply Susp_ind.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; functor_susp f y = functor_susp g y)
  North</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chkd"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; functor_susp f y = functor_susp g y)
  South</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="psusp-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chke"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   functor_susp f y = functor_susp g y) 
  (merid x) <span class="nl">?H_N</span> = <span class="nl">?H_S</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chkf"><span class="highlight"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">reflexivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   functor_susp f y = functor_susp g y) (merid x) <span class="mi">1</span> =
<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk10"><span class="highlight"><span class="nb">intro</span> x; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   functor_susp f y = functor_susp g y) (merid x) <span class="mi">1</span> =
<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk11"><span class="highlight"><span class="nb">rewrite</span> transport_paths_FlFr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((ap (functor_susp f) (merid x))^ @ <span class="mi">1</span>) @
ap (functor_susp g) (merid x) = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk12"><span class="highlight"><span class="nb">rewrite</span> concat_p1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ap (functor_susp f) (merid x))^ @
ap (functor_susp g) (merid x) = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk13"><span class="highlight"><span class="nb">rewrite</span> <span class="mi">2</span> Susp_rec_beta_merid.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(merid (f x))^ @ merid (g x) = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk14"><span class="highlight"><span class="nb">destruct</span> (p x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(merid (f x))^ @ merid (f x) = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> concat_Vp.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk15"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Susp_ind
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   functor_susp f y = functor_susp g y) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   internal_paths_rew_r
     (functor_susp f South = functor_susp g South)
     (transport
        (<span class="kr">fun</span> <span class="nv">x0</span> : Susp X =&gt;
         functor_susp f x0 = functor_susp g x0)
        (merid x) <span class="mi">1</span>)
     (((ap (functor_susp f) (merid x))^ @ <span class="mi">1</span>) @
      ap (functor_susp g) (merid x))
     (<span class="kr">fun</span>
        <span class="nv">p</span> : functor_susp f South =
            functor_susp g South =&gt; p = <span class="mi">1</span>)
     (internal_paths_rew_r
        (functor_susp f South = functor_susp f North)
        ((ap (functor_susp f) (merid x))^ @ <span class="mi">1</span>)
        (ap (functor_susp f) (merid x))^
        (<span class="kr">fun</span>
           <span class="nv">p</span> : functor_susp f South =
               functor_susp f North =&gt;
         p @ ap (functor_susp g) (merid x) = <span class="mi">1</span>)
        (internal_paths_rew_r
           (Susp_rec North South
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (f x0)) North =
            Susp_rec North South
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (f x0)) South)
           (ap
              (Susp_rec North South
                 (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (f x0)))
              (merid x)) (merid (f x))
           (<span class="kr">fun</span>
              <span class="nv">p</span> : Susp_rec North South
                    (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (f x0)) North =
                  Susp_rec North South
                    (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (f x0)) South
            =&gt; p^ @ ap (functor_susp g) (merid x) = <span class="mi">1</span>)
           (internal_paths_rew_r
              (Susp_rec North South
                 (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (g x0)) North =
               Susp_rec North South
                 (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (g x0)) South)
              (ap
                 (Susp_rec North South
                    (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (g x0)))
                 (merid x)) (merid (g x))
              (<span class="kr">fun</span>
                 <span class="nv">p</span> : Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (g x0))
                       North =
                     Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (g x0))
                       South =&gt; (merid (f x))^ @ p = <span class="mi">1</span>)
              (<span class="kr">let</span> <span class="nv">p0</span> := p x <span class="kr">in</span>
               <span class="kr">let</span> <span class="nv">y</span> := g x <span class="kr">in</span>
               <span class="kr">match</span>
                 p0 <span class="kr">in</span> (_ = y0)
                 <span class="kr">return</span>
                   ((merid (f x))^ @ merid y0 = <span class="mi">1</span>)
               <span class="kr">with</span>
               | <span class="mi">1</span> =&gt; concat_Vp (merid (f x))
               <span class="kr">end</span>) (Susp_rec_beta_merid x))
           (Susp_rec_beta_merid x))
        (concat_p1 (ap (functor_susp f) (merid x))^))
     (transport_paths_FlFr (merid x) <span class="mi">1</span>))
  (point
     (psusp
        {|
          pointed_type := X; ispointed_type := point0
        |})) =
dpoint_eq
  (Build_pMap
     (psusp
        {|
          pointed_type := X; ispointed_type := point0
        |})
     (psusp
        {|
          pointed_type := Y;
          ispointed_type := g point0
        |}) (functor_susp f) <span class="mi">1</span>) @
(dpoint_eq
   (Build_pMap
      (psusp
         {|
           pointed_type := X; ispointed_type := point0
         |})
      (psusp
         {|
           pointed_type := Y;
           ispointed_type := g point0
         |}) (functor_susp g) <span class="mi">1</span>))^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="sd">(** Preservation of identity. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk16"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : pType, fmap psusp (Id a) $== Id (psusp a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk17"><span class="highlight"><span class="nb">intros</span> X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap psusp (Id X) $== Id (psusp X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk18"><span class="highlight">srapply Build_pHomotopy.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap psusp (Id X) == Id (psusp X)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk19"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?p</span> (point (psusp X)) =
dpoint_eq (fmap psusp (Id X)) @
(dpoint_eq (Id (psusp X)))^</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1a"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap psusp (Id X) == Id (psusp X)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1b"><span class="highlight">srapply Susp_ind; <span class="kp">try</span> <span class="bp">reflexivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   fmap psusp (Id X) y = Id (psusp X) y) (merid x) <span class="mi">1</span> =
<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1c"><span class="highlight"><span class="nb">intro</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   fmap psusp (Id X) y = Id (psusp X) y) (merid x) <span class="mi">1</span> =
<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1d"><span class="highlight"><span class="nb">refine</span> (transport_paths_FFlr _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((ap (fmap psusp (Id X)) (ap idmap (merid x)))^ @ <span class="mi">1</span>) @
merid x = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> ap_idmap, Susp_rec_beta_merid,
        concat_p1, concat_Vp.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1e"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Susp_ind
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   fmap psusp (Id X) y = Id (psusp X) y) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   transport_paths_FFlr (merid x) <span class="mi">1</span> @
   internal_paths_rew_r (North = Id (psusp X) South)
     (ap idmap (merid x)) (merid x)
     (<span class="kr">fun</span> <span class="nv">p</span> : North = Id (psusp X) South =&gt;
      ((ap (fmap psusp (Id X)) p)^ @ <span class="mi">1</span>) @ merid x = <span class="mi">1</span>)
     (internal_paths_rew_r
        (Susp_rec North South
           (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (Id X x0)) North =
         Susp_rec North South
           (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (Id X x0)) South)
        (ap
           (Susp_rec North South
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (Id X x0)))
           (merid x)) (merid (Id X x))
        (<span class="kr">fun</span>
           <span class="nv">p</span> : Susp_rec North South
                 (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (Id X x0)) North =
               Susp_rec North South
                 (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (Id X x0)) South
         =&gt; (p^ @ <span class="mi">1</span>) @ merid x = <span class="mi">1</span>)
        (internal_paths_rew_r
           (fmap psusp (Id X) (Id (psusp X) South) =
            fmap psusp (Id X) North)
           ((merid (Id X x))^ @ <span class="mi">1</span>) (merid (Id X x))^
           (<span class="kr">fun</span>
              <span class="nv">p</span> : fmap psusp (Id X)
                    (Id (psusp X) South) =
                  fmap psusp (Id X) North =&gt;
            p @ merid x = <span class="mi">1</span>)
           (internal_paths_rew_r
              (fmap psusp (Id X) (Id (psusp X) South) =
               fmap psusp (Id X) (Id (psusp X) South))
              ((merid x)^ @ merid x) <span class="mi">1</span>
              (<span class="kr">fun</span>
                 <span class="nv">p</span> : fmap psusp (Id X)
                       (Id (psusp X) South) =
                     fmap psusp (Id X)
                       (Id (psusp X) South) =&gt; p = <span class="mi">1</span>)
              <span class="mi">1</span> (concat_Vp (merid x)))
           (concat_p1 (merid (Id X x))^))
        (Susp_rec_beta_merid x)) (ap_idmap (merid x)))
  (point (psusp X)) =
dpoint_eq (fmap psusp (Id X)) @
(dpoint_eq (Id (psusp X)))^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="sd">(** Preservation of composition. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap psusp (g $o f) $== fmap psusp g $o fmap psusp f</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk20"><span class="highlight">pointed_reduce_rewrite; srefine (Build_pHomotopy _ _); <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a -&gt;* b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b -&gt;* c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt; functor_susp g (functor_susp f x))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a -&gt;* b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b -&gt;* c</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk21"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> ispointed_susp = <span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk22"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a -&gt;* b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b -&gt;* c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt; functor_susp g (functor_susp f x))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk23"><span class="highlight">srapply Susp_ind; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a -&gt;* b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b -&gt;* c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : a,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp a =&gt;
   functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)) y =
   functor_susp g (functor_susp f y)) (merid x) <span class="mi">1</span> = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk24"><span class="highlight"><span class="nb">intros</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a -&gt;* b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b -&gt;* c</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp a =&gt;
   functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x)) y =
   functor_susp g (functor_susp f y)) (merid x) <span class="mi">1</span> = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk25"><span class="highlight"><span class="nb">refine</span> (transport_paths_FlFr _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a -&gt;* b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b -&gt;* c</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((ap (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x))) (merid x))^ @
 <span class="mi">1</span>) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt; functor_susp g (functor_susp f x))
  (merid x) = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk26"><span class="highlight"><span class="nb">rewrite</span> concat_p1; <span class="nb">apply</span> moveR_Vp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a -&gt;* b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b -&gt;* c</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt; functor_susp g (functor_susp f x))
  (merid x) =
ap (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x))) (merid x) @ <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> concat_p1, ap_compose, !Susp_rec_beta_merid.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk27"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a -&gt;* b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b -&gt;* c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Susp_ind
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp a =&gt;
   functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x)) y =
   (<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt;
    functor_susp g (functor_susp f x)) y) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt;
   transport_paths_FlFr (merid x) <span class="mi">1</span> @
   internal_paths_rew_r
     (functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)) South =
      functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)) North)
     ((ap (functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
         (merid x))^ @ <span class="mi">1</span>)
     (ap (functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
        (merid x))^
     (<span class="kr">fun</span>
        <span class="nv">p</span> : functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0))
              South =
            functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0))
              North =&gt;
      p @
      ap
        (<span class="kr">fun</span> <span class="nv">x0</span> : Susp a =&gt;
         functor_susp g (functor_susp f x0)) (merid x) =
      <span class="mi">1</span>)
     (moveR_Vp
        (ap
           (<span class="kr">fun</span> <span class="nv">x0</span> : Susp a =&gt;
            functor_susp g (functor_susp f x0))
           (merid x)) <span class="mi">1</span>
        (ap (functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
           (merid x))
        (internal_paths_rew_r
           (functor_susp g (functor_susp f North) =
            functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0))
              South)
           (ap (functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
              (merid x) @ <span class="mi">1</span>)
           (ap (functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
              (merid x))
           (<span class="kr">fun</span>
              <span class="nv">p</span> : functor_susp g
                    (functor_susp f North) =
                  functor_susp
                    (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)) South =&gt;
            ap
              (<span class="kr">fun</span> <span class="nv">x0</span> : Susp a =&gt;
               functor_susp g (functor_susp f x0))
              (merid x) = p)
           (internal_paths_rew_r
              (functor_susp g (functor_susp f North) =
               functor_susp g (functor_susp f South))
              (ap
                 (<span class="kr">fun</span> <span class="nv">x0</span> : Susp a =&gt;
                  functor_susp g (functor_susp f x0))
                 (merid x))
              (ap (functor_susp g)
                 (ap (functor_susp f) (merid x)))
              (<span class="kr">fun</span>
                 <span class="nv">p</span> : functor_susp g
                       (functor_susp f North) =
                     functor_susp g
                       (functor_susp f South) =&gt;
               p =
               ap
                 (functor_susp
                    (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
                 (merid x))
              (internal_paths_rew_r
                 (Susp_rec North South
                    (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; merid (f x0)) North =
                  Susp_rec North South
                    (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; merid (f x0)) South)
                 (ap
                    (Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; merid (f x0)))
                    (merid x)) (merid (f x))
                 (<span class="kr">fun</span>
                    <span class="nv">p</span> : Susp_rec North South
                          (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; merid (f x0))
                          North =
                        Susp_rec North South
                          (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; merid (f x0))
                          South =&gt;
                  ap (functor_susp g) p =
                  ap
                    (functor_susp
                       (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
                    (merid x))
                 (internal_paths_rew_r
                    (Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : b =&gt; merid (g x0))
                       North =
                     Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : b =&gt; merid (g x0))
                       South)
                    (ap
                       (Susp_rec North South
                          (<span class="kr">fun</span> <span class="nv">x0</span> : b =&gt; merid (g x0)))
                       (merid (f x)))
                    (merid (g (f x)))
                    (<span class="kr">fun</span>
                       <span class="nv">p</span> : Susp_rec North South
                             (<span class="kr">fun</span> <span class="nv">x0</span> : b =&gt;
                              merid (g x0)) North =
                           Susp_rec North South
                             (<span class="kr">fun</span> <span class="nv">x0</span> : b =&gt;
                              merid (g x0)) South =&gt;
                     p =
                     ap
                       (functor_susp
                          (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
                       (merid x))
                    (internal_paths_rew_r
                       (Susp_rec North South
                          (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt;
                           merid (g (...))) North =
                        Susp_rec North South
                          (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt;
                           merid (g (...))) South)
                       (ap
                          (Susp_rec North South
                             (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt;
                              merid (g ...)))
                          (merid x)) (merid (g (f x)))
                       (<span class="kr">fun</span>
                          <span class="nv">p</span> : Susp_rec North South
                                (<span class="kr">fun</span> ... =&gt; merid ...)
                                North =
                              Susp_rec North South
                                (<span class="kr">fun</span> ... =&gt; merid ...)
                                South =&gt;
                        merid (g (f x)) = p) <span class="mi">1</span>
                       (Susp_rec_beta_merid x))
                    (Susp_rec_beta_merid (f x)))
                 (Susp_rec_beta_merid x))
              (ap_compose (functor_susp f)
                 (functor_susp g) (merid x)))
           (concat_p1
              (ap
                 (functor_susp
                    (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
                 (merid x)))))
     (concat_p1
        (ap (functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
           (merid x))^)) ispointed_susp = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Loop-Suspension Adjunction *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Book_Loop_Susp_Adjunction</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Here is the proof of the adjunction isomorphism given in the book (6.5.4); we put it in a non-exported module for reasons discussed below. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk28"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_adjoint</span> `{Funext} (A B : pType)
  : (psusp A -&gt;* B) &lt;~&gt; (A -&gt;* loops B).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(psusp A -&gt;* B) &lt;~&gt; (A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk29"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(psusp A -&gt;* B) &lt;~&gt; (A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2a"><span class="highlight"><span class="nb">refine</span> (_ oE (issig_pmap (psusp A) B)^-<span class="mi">1</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{f : psusp A -&gt; B &amp; f (point (psusp A)) = point B} &lt;~&gt;
(A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2b"><span class="highlight"><span class="nb">refine</span> (_ oE (equiv_functor_sigma_pb
                 (Q := <span class="kr">fun</span> <span class="nv">NSm</span> =&gt; fst NSm.<span class="mi">1</span> = point B)
                 (equiv_Susp_rec A B))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{NSm : {NS : B * B &amp; A -&gt; fst NS = snd NS} &amp;
fst NSm.<span class="mi">1</span> = point B} &lt;~&gt; (A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2c"><span class="highlight"><span class="nb">transitivity</span> {bp : {b:B &amp; b = point B} &amp; {b:B &amp; A -&gt; bp.<span class="mi">1</span> = b} }.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{NSm : {NS : B * B &amp; A -&gt; fst NS = snd NS} &amp;
fst NSm.<span class="mi">1</span> = point B} &lt;~&gt;
{bp : {b : B &amp; b = point B} &amp; {b : B &amp; A -&gt; bp.<span class="mi">1</span> = b}}</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk2d"><hr></label><div class="goal-conclusion"><span class="highlight">{bp : {b : B &amp; b = point B} &amp; {b : B &amp; A -&gt; bp.<span class="mi">1</span> = b}} &lt;~&gt;
(A -&gt;* loops B)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2e"><span class="highlight"><span class="mi">1</span>:make_equiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{bp : {b : B &amp; b = point B} &amp; {b : B &amp; A -&gt; bp.<span class="mi">1</span> = b}} &lt;~&gt;
(A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2f"><span class="highlight"><span class="nb">refine</span> (_ oE equiv_contr_sigma _); <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{b : B &amp; A -&gt; point B = b} &lt;~&gt; (A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk30"><span class="highlight"><span class="nb">refine</span> (_ oE (equiv_sigma_contr
                   (A := {p : B &amp; A -&gt; point B = p})
                   (<span class="kr">fun</span> <span class="nv">pm</span> =&gt; { q : point B = pm.<span class="mi">1</span> &amp; pm.<span class="mi">2</span> (point A) = q }))^-<span class="mi">1</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{pm : {p : B &amp; A -&gt; point B = p} &amp;
{q : point B = pm.<span class="mi">1</span> &amp; pm.<span class="mi">2</span> (point A) = q}} &lt;~&gt;
(A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk31"><span class="highlight"><span class="nb">transitivity</span> {bp : {b:B &amp; point B = b} &amp; {f : A -&gt; point B = bp.<span class="mi">1</span> &amp; f (point A) = bp.<span class="mi">2</span>} }.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{pm : {p : B &amp; A -&gt; point B = p} &amp;
{q : point B = pm.<span class="mi">1</span> &amp; pm.<span class="mi">2</span> (point A) = q}} &lt;~&gt;
{bp : {b : B &amp; point B = b} &amp;
{f : A -&gt; point B = bp.<span class="mi">1</span> &amp; f (point A) = bp.<span class="mi">2</span>}}</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk32"><hr></label><div class="goal-conclusion"><span class="highlight">{bp : {b : B &amp; point B = b} &amp;
{f : A -&gt; point B = bp.<span class="mi">1</span> &amp; f (point A) = bp.<span class="mi">2</span>}} &lt;~&gt;
(A -&gt;* loops B)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk33"><span class="highlight"><span class="mi">1</span>:make_equiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{bp : {b : B &amp; point B = b} &amp;
{f : A -&gt; point B = bp.<span class="mi">1</span> &amp; f (point A) = bp.<span class="mi">2</span>}} &lt;~&gt;
(A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk34"><span class="highlight"><span class="nb">refine</span> (_ oE equiv_contr_sigma _); <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{f : A -&gt; point B = point B &amp; f (point A) = <span class="mi">1</span>} &lt;~&gt;
(A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (issig_pmap A (loops B)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Unfortunately, with this definition it seems to be quite hard to prove that the isomorphism is natural on pointed maps.  The following proof gets partway there, but ends with a pretty intractable goal.  It&#39;s also quite slow, so we don&#39;t want to compile it all the time. *)</span>
  <span class="sd">(**</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">  Definition loop_susp_adjoint_nat_r `{Funext} (A B B&#39; : pType)</span>
<span class="sd">             (f : psusp A -&gt;* B) (g : B -&gt;* B&#39;)</span>
<span class="sd">  : loop_susp_adjoint A B&#39; (g o* f)</span>
<span class="sd">    ==* loops_functor g o* loop_susp_adjoint A B f.</span>
<span class="sd">  Proof.</span>
<span class="sd">    pointed_reduce_rewrite.</span>
<span class="sd">    srefine (Build_pHomotopy _ _).</span>
<span class="sd">    - intros a. simpl.</span>
<span class="sd">      refine (_ @ (concat_1p _)^).</span>
<span class="sd">      refine (_ @ (concat_p1 _)^).</span>
<span class="sd">      rewrite !transport_sigma. simpl.</span>
<span class="sd">      rewrite !(transport_arrow_fromconst (B := A)).</span>
<span class="sd">      rewrite !transport_paths_Fr.</span>
<span class="sd">      rewrite !ap_V, !ap_pr1_path_basedpaths.</span>
<span class="sd">      rewrite ap_pp, !(ap_compose f g), ap_V.</span>
<span class="sd">      reflexivity.</span>
<span class="sd">    - cbn.</span>
<span class="sd">      Fail reflexivity.</span>
<span class="sd">  Abort.</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">   *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Book_Loop_Susp_Adjunction</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Thus, instead we will construct the adjunction in terms of a unit and counit natural transformation. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_unit</span> (<span class="nv">X</span> : pType) : X -&gt;* loops (psusp X)
  := Build_pMap X (loops (psusp X))
      (<span class="kr">fun</span> <span class="nv">x</span> =&gt; merid x @ (merid (point X))^) (concat_pV _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** By Freudenthal, we have that this map is 2n-connected for a n-connected X *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk35"><span class="highlight"><span class="kn">Instance</span> <span class="nf">conn_map_loop_susp_unit</span> `{Univalence}
  (X : pType) `{IsConnected n.+<span class="mi">1</span> X}
  : IsConnMap (n +<span class="mi">2</span>+ n) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; merid x @ (merid (point X))^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (n +<span class="mi">2</span>+ n))
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid (point X))^)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk36"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (n +<span class="mi">2</span>+ n))
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid (point X))^)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (conn_map_compose _ _ (equiv_concat_r (merid (point _))^ _)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We also have this corollary *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk37"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">pequiv_ptr_loop_psusp</span> `{Univalence} (X : pType) n `{IsConnected n.+<span class="mi">1</span> X}
  : pTr (n +<span class="mi">2</span>+ n) X &lt;~&gt;* pTr (n +<span class="mi">2</span>+ n) (loops (psusp X)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pTr (n +<span class="mi">2</span>+ n) X &lt;~&gt;* pTr (n +<span class="mi">2</span>+ n) (loops (psusp X))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk38"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pTr (n +<span class="mi">2</span>+ n) X &lt;~&gt;* pTr (n +<span class="mi">2</span>+ n) (loops (psusp X))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk39"><span class="highlight">snrapply Build_pEquiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pTr (n +<span class="mi">2</span>+ n) X -&gt;* pTr (n +<span class="mi">2</span>+ n) (loops (psusp X))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk3a"><hr></label><div class="goal-conclusion"><span class="highlight">IsEquiv <span class="nl">?pointed_equiv_fun</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3b"><span class="highlight"><span class="mi">1</span>:rapply (fmap (pTr _) (loop_susp_unit _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (fmap (pTr (n +<span class="mi">2</span>+ n)) (loop_susp_unit X))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">rapply O_inverts_conn_map.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3c"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_unit_natural</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType} (<span class="nv">f</span> : X -&gt;* Y)
  : loop_susp_unit Y o* f
  ==* fmap loops (fmap psusp f) o* loop_susp_unit X.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt;* Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_unit Y o* f ==*
fmap loops (fmap psusp f) o* loop_susp_unit X</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt;* Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_unit Y o* f ==*
fmap loops (fmap psusp f) o* loop_susp_unit X</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3e"><span class="highlight">pointed_reduce.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_unit
  {| pointed_type := Y; ispointed_type := f point0 |}
o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} ==*
Build_pMap
  (loops
     (psusp
        {|
          pointed_type := X; ispointed_type := point0
        |}))
  (loops
     (psusp
        {|
          pointed_type := Y;
          ispointed_type := f point0
        |}))
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>)) <span class="mi">1</span>
o* loop_susp_unit
     {| pointed_type := X; ispointed_type := point0 |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3f"><span class="highlight"><span class="nb">simple refine</span> (Build_pHomotopy _ _); <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x) @ (merid (f point0))^) ==
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 <span class="mi">1</span> @
 (ap (functor_susp f) (merid x @ (merid point0)^) @ <span class="mi">1</span>))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk40"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> point0 =
(<span class="mi">1</span> @ concat_pV (merid (f point0))) @
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
    <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
   (concat_pV (merid point0)) @ <span class="mi">1</span>)^</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk41"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x) @ (merid (f point0))^) ==
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 <span class="mi">1</span> @
 (ap (functor_susp f) (merid x @ (merid point0)^) @ <span class="mi">1</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk42"><span class="highlight"><span class="nb">intros</span> x; <span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> @
(ap (functor_susp f) (merid x @ (merid point0)^) @ <span class="mi">1</span>) =
merid (f x) @ (merid (f point0))^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk43"><span class="highlight"><span class="nb">refine</span> (concat_1p _@ (concat_p1 _ @ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (functor_susp f) (merid x @ (merid point0)^) =
merid (f x) @ (merid (f point0))^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk44"><span class="highlight"><span class="nb">refine</span> (ap_pp (Susp_rec North South (merid o f))
                  (merid x) (merid (point X))^ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
  (merid x) @
ap (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
  (merid (point X))^ =
merid (f x) @ (merid (f point0))^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk45"><span class="highlight"><span class="nb">refine</span> ((<span class="mi">1</span> @@ ap_V _ _) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
  (merid x) @
(ap (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
   (merid (point X)))^ =
merid (f x) @ (merid (f point0))^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (Susp_rec_beta_merid _ @@ inverse2 (Susp_rec_beta_merid _)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk46"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 (concat_1p
    (ap (functor_susp f) (merid x @ (merid point0)^) @
     <span class="mi">1</span>) @
  (concat_p1
     (ap (functor_susp f) (merid x @ (merid point0)^)) @
   (ap_pp (Susp_rec North South (merid o f)) 
      (merid x) (merid (point X))^ @
    ((<span class="mi">1</span> @@
      ap_V
        (Susp_rec North South
           (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (f x0)))
        (merid (point X))) @
     (Susp_rec_beta_merid x @@
      inverse2 (Susp_rec_beta_merid (point X)))))))^)
  point0 =
(<span class="mi">1</span> @ concat_pV (merid (f point0))) @
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
    <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
   (concat_pV (merid point0)) @ <span class="mi">1</span>)^</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk47"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(concat_1p
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pp
     (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
     (merid point0) (merid (point X))^ @
   ((<span class="mi">1</span> @@
     ap_V
       (Susp_rec North South
          (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
       (merid (point X))) @
    (Susp_rec_beta_merid point0 @@
     inverse2 (Susp_rec_beta_merid (point X)))))))^ =
(<span class="mi">1</span> @ concat_pV (merid (f point0))) @
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
    <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
   (concat_pV (merid point0)) @ <span class="mi">1</span>)^</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk48"><span class="highlight"><span class="nb">apply</span> moveL_pV.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(concat_1p
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pp
     (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
     (merid point0) (merid (point X))^ @
   ((<span class="mi">1</span> @@
     ap_V
       (Susp_rec North South
          (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
       (merid (point X))) @
    (Susp_rec_beta_merid point0 @@
     inverse2 (Susp_rec_beta_merid (point X)))))))^ @
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
    <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
   (concat_pV (merid point0)) @ <span class="mi">1</span>) =
<span class="mi">1</span> @ concat_pV (merid (f point0))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk49"><span class="highlight"><span class="nb">rewrite</span> !inv_pp, !concat_pp_p, concat_1p; <span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">concat_pV (merid (f point0)) =
(Susp_rec_beta_merid point0 @@
 inverse2 (Susp_rec_beta_merid (point X)))^ @
((<span class="mi">1</span> @@
  ap_V
    (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
    (merid (point X)))^ @
 ((ap_pp
     (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
     (merid point0) (merid (point X))^)^ @
  ((concat_p1
      (ap (functor_susp f)
         (merid point0 @ (merid point0)^)))^ @
   ((concat_1p
       (ap (functor_susp f)
          (merid point0 @ (merid point0)^) @ <span class="mi">1</span>))^ @
    (ap
       (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
        <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
       (concat_pV (merid point0)) @ <span class="mi">1</span>)))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4a"><span class="highlight"><span class="nb">apply</span> moveL_Vp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(Susp_rec_beta_merid point0 @@
 inverse2 (Susp_rec_beta_merid (point X))) @
concat_pV (merid (f point0)) =
(<span class="mi">1</span> @@
 ap_V
   (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
   (merid (point X)))^ @
((ap_pp
    (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
    (merid point0) (merid (point X))^)^ @
 ((concat_p1
     (ap (functor_susp f)
        (merid point0 @ (merid point0)^)))^ @
  ((concat_1p
      (ap (functor_susp f)
         (merid point0 @ (merid point0)^) @ <span class="mi">1</span>))^ @
   (ap
      (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
       <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
      (concat_pV (merid point0)) @ <span class="mi">1</span>))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4b"><span class="highlight"><span class="nb">refine</span> (concat_pV_inverse2 _ _ (Susp_rec_beta_merid (point X)) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">concat_pV
  (ap
     (Susp_rec (Coeq.Coeq.coeq (inl tt)) South
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))) 
     (merid (point X))) =
(<span class="mi">1</span> @@
 ap_V
   (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
   (merid (point X)))^ @
((ap_pp
    (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
    (merid point0) (merid (point X))^)^ @
 ((concat_p1
     (ap (functor_susp f)
        (merid point0 @ (merid point0)^)))^ @
  ((concat_1p
      (ap (functor_susp f)
         (merid point0 @ (merid point0)^) @ <span class="mi">1</span>))^ @
   (ap
      (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
       <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
      (concat_pV (merid point0)) @ <span class="mi">1</span>))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4c"><span class="highlight"><span class="nb">apply</span> moveL_Vp, moveL_Vp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap_pp
  (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
  (merid point0) (merid (point X))^ @
((<span class="mi">1</span> @@
  ap_V
    (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
    (merid (point X))) @
 concat_pV
   (ap
      (Susp_rec (Coeq.Coeq.coeq (inl tt)) South
         (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))) 
      (merid (point X)))) =
(concat_p1
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^)))^ @
((concat_1p
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^) @ <span class="mi">1</span>))^ @
 (ap
    (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
     <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
    (concat_pV (merid point0)) @ <span class="mi">1</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4d"><span class="highlight"><span class="nb">refine</span> (ap_pp_concat_pV _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (ap
     (Susp_rec (Coeq.Coeq.coeq (inl tt)) South
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))))
  (concat_pV (merid point0)) =
(concat_p1
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^)))^ @
((concat_1p
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^) @ <span class="mi">1</span>))^ @
 (ap
    (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
     <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
    (concat_pV (merid point0)) @ <span class="mi">1</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4e"><span class="highlight"><span class="nb">apply</span> moveL_Vp, moveL_Vp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">concat_1p
  (ap (functor_susp f)
     (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
(concat_p1
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^)) @
 ap
   (ap
      (Susp_rec (Coeq.Coeq.coeq (inl tt)) South
         (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))))
   (concat_pV (merid point0))) =
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
  (concat_pV (merid point0)) @ <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4f"><span class="highlight"><span class="nb">rewrite</span> concat_p1_1, concat_1p_1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (<span class="kr">fun</span>
     <span class="nv">p&#39;</span> : Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
          Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt; 
   <span class="mi">1</span> @ p&#39;)
  (ap
     (<span class="kr">fun</span>
        <span class="nv">p&#39;</span> : Susp_rec (Coeq.Coeq.coeq (inl tt)) South
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
             Susp_rec (Coeq.Coeq.coeq (inl tt)) South
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt;
      p&#39; @ <span class="mi">1</span>)
     (ap
        (ap
           (Susp_rec (Coeq.Coeq.coeq (inl tt)) South
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))))
        (concat_pV (merid point0)))) =
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
  (concat_pV (merid point0)) @ <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk50"><span class="highlight"><span class="nb">cbn</span>; <span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
  (concat_pV (merid point0)) @ <span class="mi">1</span> =
ap
  (<span class="kr">fun</span>
     <span class="nv">p&#39;</span> : Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
          Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt; 
   <span class="mi">1</span> @ p&#39;)
  (ap
     (<span class="kr">fun</span>
        <span class="nv">p&#39;</span> : Susp_rec (Coeq.Coeq.coeq (inl tt)) South
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
             Susp_rec (Coeq.Coeq.coeq (inl tt)) South
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt;
      p&#39; @ <span class="mi">1</span>)
     (ap
        (ap
           (Susp_rec (Coeq.Coeq.coeq (inl tt)) South
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))))
        (concat_pV (merid point0))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk51"><span class="highlight"><span class="nb">refine</span> (concat_p1 _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
  (concat_pV (merid point0)) =
ap
  (<span class="kr">fun</span>
     <span class="nv">p&#39;</span> : Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
          Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt; 
   <span class="mi">1</span> @ p&#39;)
  (ap
     (<span class="kr">fun</span>
        <span class="nv">p&#39;</span> : Susp_rec (Coeq.Coeq.coeq (inl tt)) South
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
             Susp_rec (Coeq.Coeq.coeq (inl tt)) South
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt;
      p&#39; @ <span class="mi">1</span>)
     (ap
        (ap
           (Susp_rec (Coeq.Coeq.coeq (inl tt)) South
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))))
        (concat_pV (merid point0))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk52"><span class="highlight"><span class="nb">refine</span> (ap_compose
      (<span class="kr">fun</span> <span class="nv">p&#39;</span> =&gt; (ap (Susp_rec North South (merid o f))) p&#39; @ <span class="mi">1</span>)
      (<span class="kr">fun</span> <span class="nv">p&#39;</span> =&gt; <span class="mi">1</span> @ p&#39;)
      (concat_pV (merid (point X))) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (<span class="kr">fun</span>
     <span class="nv">p&#39;</span> : Susp_rec North South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
          Susp_rec North South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt; 
   <span class="mi">1</span> @ p&#39;)
  (ap
     (<span class="kr">fun</span> <span class="nv">p&#39;</span> : North = North =&gt;
      ap
        (Susp_rec North South
           (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))) p&#39; @ <span class="mi">1</span>)
     (concat_pV (merid (point X)))) =
ap
  (<span class="kr">fun</span>
     <span class="nv">p&#39;</span> : Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
          Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt; 
   <span class="mi">1</span> @ p&#39;)
  (ap
     (<span class="kr">fun</span>
        <span class="nv">p&#39;</span> : Susp_rec (Coeq.Coeq.coeq (inl tt)) South
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
             Susp_rec (Coeq.Coeq.coeq (inl tt)) South
               (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt;
      p&#39; @ <span class="mi">1</span>)
     (ap
        (ap
           (Susp_rec (Coeq.Coeq.coeq (inl tt)) South
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))))
        (concat_pV (merid point0))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk53"><span class="highlight"><span class="nb">apply</span> ap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (<span class="kr">fun</span> <span class="nv">p&#39;</span> : North = North =&gt;
   ap
     (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)))
     p&#39; @ <span class="mi">1</span>) (concat_pV (merid (point X))) =
ap
  (<span class="kr">fun</span>
     <span class="nv">p&#39;</span> : Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =
          Susp_rec (Coeq.Coeq.coeq (inl tt)) South
            (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x)) North =&gt; 
   p&#39; @ <span class="mi">1</span>)
  (ap
     (ap
        (Susp_rec (Coeq.Coeq.coeq (inl tt)) South
           (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x))))
     (concat_pV (merid point0)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (ap_compose (ap (Susp_rec North South (merid o f)))
      (<span class="kr">fun</span> <span class="nv">p&#39;</span> =&gt; p&#39; @ <span class="mi">1</span>) _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_counit</span> (<span class="nv">X</span> : pType) : psusp (loops X) -&gt;* X
  :=  Build_pMap (psusp (loops X)) X (Susp_rec (point X) (point X) idmap) <span class="mi">1</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk54"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_counit_natural</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType} (<span class="nv">f</span> : X -&gt;* Y)
  : f o* loop_susp_counit X
  ==* loop_susp_counit Y o* fmap psusp (fmap loops f).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt;* Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f o* loop_susp_counit X ==*
loop_susp_counit Y o* fmap psusp (fmap loops f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk55"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt;* Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f o* loop_susp_counit X ==*
loop_susp_counit Y o* fmap psusp (fmap loops f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk56"><span class="highlight">pointed_reduce.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
o* loop_susp_counit
     {| pointed_type := X; ispointed_type := point0 |} ==*
loop_susp_counit
  {| pointed_type := Y; ispointed_type := f point0 |}
o* Build_pMap
     (psusp
        (loops
           {|
             pointed_type := X;
             ispointed_type := point0
           |}))
     (psusp
        (loops
           {|
             pointed_type := Y;
             ispointed_type := f point0
           |}))
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)))
     <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk57"><span class="highlight"><span class="nb">simple refine</span> (Build_pHomotopy _ _); <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
 f (Susp_rec (point X) (point X) idmap x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
 Susp_rec (point Y) (point Y) idmap
   (functor_susp
      (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) x))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk58"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> (point (Susp (point X = point X))) = <span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk59"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
 f (Susp_rec (point X) (point X) idmap x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
 Susp_rec (point Y) (point Y) idmap
   (functor_susp
      (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) x))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5a"><span class="highlight"><span class="nb">simple refine</span> (Susp_ind _ _ _ _); <span class="nb">cbn</span>; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="nb">intros</span> p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">point X = point X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp (point X = point X) =&gt;
   f (Susp_rec (point X) (point X) idmap y) =
   Susp_rec (point Y) (point Y) idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
        y)) (merid p) <span class="mi">1</span> = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5b"><span class="highlight"><span class="nb">rewrite</span> transport_paths_FlFr, ap_compose, concat_p1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">point X = point X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ap f
   (ap (Susp_rec (point X) (point X) idmap) (merid p)))^ @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
   Susp_rec (point Y) (point Y) idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
        x)) (merid p) = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5c"><span class="highlight"><span class="nb">apply</span> moveR_Vp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">point X = point X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
   Susp_rec (point Y) (point Y) idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
        x)) (merid p) =
ap f
  (ap (Susp_rec (point X) (point X) idmap) (merid p)) @
<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5d"><span class="highlight"><span class="nb">refine</span> (ap_compose
              (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x0</span> =&gt; merid (<span class="mi">1</span> @ (ap f x0 @ <span class="mi">1</span>))))
              (Susp_rec (point Y) (point Y) idmap) (merid p) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">point X = point X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (Susp_rec (point Y) (point Y) idmap)
  (ap
     (Susp_rec North South
        (<span class="kr">fun</span> <span class="nv">x0</span> : point X = point X =&gt;
         merid (<span class="mi">1</span> @ (ap f x0 @ <span class="mi">1</span>)))) 
     (merid p)) =
ap f
  (ap (Susp_rec (point X) (point X) idmap) (merid p)) @
<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5e"><span class="highlight"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> Susp_rec_beta_merid.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">point X = point X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>) =
ap f
  (ap (Susp_rec (point X) (point X) idmap) (merid p)) @
<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5f"><span class="highlight"><span class="nb">refine</span> (concat_1p _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">point X = point X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap f p @ <span class="mi">1</span> =
ap f
  (ap (Susp_rec (point X) (point X) idmap) (merid p)) @
<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk60"><span class="highlight">f_ap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">point X = point X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap f p =
ap f
  (ap (Susp_rec (point X) (point X) idmap) (merid p))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk61"><span class="highlight">f_ap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">point X = point X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">p = ap (Susp_rec (point X) (point X) idmap) (merid p)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk62"><span class="highlight"><span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">point X = point X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (Susp_rec (point X) (point X) idmap) (merid p) = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (Susp_rec_beta_merid _).</span></span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk63"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">point0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Susp_ind
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp (point X = point X) =&gt;
   (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
    f (Susp_rec (point X) (point X) idmap x)) y =
   (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
    Susp_rec (point Y) (point Y) idmap
      (functor_susp
         (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
         x)) y) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">p</span> : point X = point X =&gt;
   internal_paths_rew_r
     (f (Susp_rec (point X) (point X) idmap South) =
      Susp_rec (point Y) 
        (point Y) idmap
        (functor_susp
           (<span class="kr">fun</span> <span class="nv">p0</span> : point0 = point0 =&gt;
            <span class="mi">1</span> @ (ap f p0 @ <span class="mi">1</span>)) South))
     (transport
        (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
         f (Susp_rec (point X) (point X) idmap x) =
         Susp_rec (point Y) 
           (point Y) idmap
           (functor_susp
              (<span class="kr">fun</span> <span class="nv">p0</span> : point0 = point0 =&gt;
               <span class="mi">1</span> @ (ap f p0 @ <span class="mi">1</span>)) x)) 
        (merid p) <span class="mi">1</span>)
     (((ap
          (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
           f (Susp_rec (point X) (point X) idmap x))
          (merid p))^ @ <span class="mi">1</span>) @
      ap
        (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
         Susp_rec (point Y) 
           (point Y) idmap
           (functor_susp
              (<span class="kr">fun</span> <span class="nv">p0</span> : point0 = point0 =&gt;
               <span class="mi">1</span> @ (ap f p0 @ <span class="mi">1</span>)) x)) 
        (merid p))
     (<span class="kr">fun</span>
        <span class="nv">p0</span> : f
               (Susp_rec 
                  (point X) 
                  (point X) idmap South) =
             Susp_rec (point Y) 
               (point Y) idmap
               (functor_susp
                  (<span class="kr">fun</span> <span class="nv">p0</span> : point0 = point0 =&gt;
                   <span class="mi">1</span> @ (ap f p0 @ <span class="mi">1</span>)) South) =&gt; 
      p0 = <span class="mi">1</span>)
     (internal_paths_rew_r
        (f (Susp_rec (point X) (point X) idmap North) =
         f (Susp_rec (point X) (point X) idmap South))
        (ap
           (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
            f (Susp_rec (point X) (point X) idmap x))
           (merid p))
        (ap f
           (ap (Susp_rec (point X) (point X) idmap)
              (merid p)))
        (<span class="kr">fun</span>
           <span class="nv">p0</span> : f
                  (Susp_rec 
                     (point X) 
                     (point X) idmap North) =
                f
                  (Susp_rec 
                     (point X) 
                     (point X) idmap South) =&gt;
         (p0^ @ <span class="mi">1</span>) @
         ap
           (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
            Susp_rec (point Y) 
              (point Y) idmap
              (functor_susp
                 (<span class="kr">fun</span> <span class="nv">p1</span> : point0 = point0 =&gt;
                  <span class="mi">1</span> @ (ap f p1 @ <span class="mi">1</span>)) x)) 
           (merid p) = <span class="mi">1</span>)
        (internal_paths_rew_r
           (f
              (Susp_rec 
                 (point X) 
                 (point X) idmap South) =
            f
              (Susp_rec 
                 (point X) 
                 (point X) idmap North))
           ((ap f
               (ap
                  (Susp_rec (point X) (point X) idmap)
                  (merid p)))^ @ <span class="mi">1</span>)
           (ap f
              (ap (Susp_rec (point X) (point X) idmap)
                 (merid p)))^
           (<span class="kr">fun</span>
              <span class="nv">p0</span> : f
                     (Susp_rec 
                       (point X) 
                       (point X) idmap South) =
                   f
                     (Susp_rec 
                       (point X) 
                       (point X) idmap North) =&gt;
            p0 @
            ap
              (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
               Susp_rec 
                 (point Y) 
                 (point Y) idmap
                 (functor_susp
                    (<span class="kr">fun</span> <span class="nv">p1</span> : point0 = point0 =&gt;
                     <span class="mi">1</span> @ (ap f p1 @ <span class="mi">1</span>)) x)) 
              (merid p) = <span class="mi">1</span>)
           (moveR_Vp
              (ap
                 (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point X = point X) =&gt;
                  Susp_rec 
                    (point Y) 
                    (point Y) idmap
                    (functor_susp
                       (<span class="kr">fun</span> <span class="nv">p0</span> : point0 = point0 =&gt;
                       <span class="mi">1</span> @ (ap f p0 @ <span class="mi">1</span>)) x))
                 (merid p)) <span class="mi">1</span>
              (ap f
                 (ap
                    (Susp_rec 
                       (point X) 
                       (point X) idmap) 
                    (merid p)))
              (ap_compose
                 (Susp_rec North South
                    (<span class="kr">fun</span> <span class="nv">x0</span> : point X = point X =&gt;
                     merid (<span class="mi">1</span> @ (ap f x0 @ <span class="mi">1</span>))))
                 (Susp_rec (point Y) (point Y) idmap)
                 (merid p) @
               internal_paths_rew_r
                 (Susp_rec North South
                    (<span class="kr">fun</span> <span class="nv">x0</span> : point X = point X =&gt;
                     merid (<span class="mi">1</span> @ (ap f x0 @ <span class="mi">1</span>))) North =
                  Susp_rec North South
                    (<span class="kr">fun</span> <span class="nv">x0</span> : point X = point X =&gt;
                     merid (<span class="mi">1</span> @ (ap f x0 @ <span class="mi">1</span>))) South)
                 (ap
                    (Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : point X = point X =&gt;
                       merid (<span class="mi">1</span> @ (ap f x0 @ <span class="mi">1</span>))))
                    (merid p))
                 (merid (<span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)))
                 (<span class="kr">fun</span>
                    <span class="nv">p0</span> : 
                     Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : point X = point X =&gt;
                       merid (<span class="mi">1</span> @ (... @ <span class="mi">1</span>))) North =
                     Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : point X = point X =&gt;
                       merid (<span class="mi">1</span> @ (... @ <span class="mi">1</span>))) South =&gt;
                  ap
                    (Susp_rec 
                       (point Y) 
                       (point Y) idmap) p0 =
                  ap f
                    (ap
                       (Susp_rec 
                       (point X) 
                       (point X) idmap) 
                       (merid p)) @ <span class="mi">1</span>)
                 (internal_paths_rew_r
                    (Susp_rec 
                       (point Y) 
                       (point Y) idmap North =
                     Susp_rec 
                       (point Y) 
                       (point Y) idmap South)
                    (ap
                       (Susp_rec 
                       (point Y) 
                       (point Y) idmap)
                       (merid (<span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))))
                    (<span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
                    (<span class="kr">fun</span>
                       <span class="nv">p0</span> : 
                       Susp_rec 
                       (point Y) 
                       (point Y) idmap North =
                       Susp_rec 
                       (point Y) 
                       (point Y) idmap South =&gt;
                     p0 =
                     ap f
                       (ap
                       (Susp_rec 
                       (point X) 
                       (point X) idmap) 
                       (merid p)) @ <span class="mi">1</span>)
                    (concat_1p (ap f p @ <span class="mi">1</span>) @
                     ap11
                       (ap11 <span class="mi">1</span>
                       (ap11 <span class="mi">1</span>
                       (Susp_rec_beta_merid p)^)) <span class="mi">1</span>)
                    (Susp_rec_beta_merid
                       (<span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))))
                 (Susp_rec_beta_merid p)))
           (concat_p1
              (ap f
                 (ap
                    (Susp_rec 
                       (point X) 
                       (point X) idmap) 
                    (merid p)))^))
        (ap_compose
           (Susp_rec (point X) (point X) idmap) f
           (merid p)))
     (transport_paths_FlFr (merid p) <span class="mi">1</span>))
  (point (Susp (point X = point X))) = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Now the triangle identities *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk64"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_triangle1</span> (<span class="nv">X</span> : pType)
  : fmap loops (loop_susp_counit X) o* loop_susp_unit (loops X)
  ==* pmap_idmap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit X)
o* loop_susp_unit (loops X) ==* pmap_idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk65"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit X)
o* loop_susp_unit (loops X) ==* pmap_idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk66"><span class="highlight"><span class="nb">simple refine</span> (Build_pHomotopy _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit X)
o* loop_susp_unit (loops X) == pmap_idmap</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk67"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?p</span> (point (loops X)) =
dpoint_eq
  (fmap loops (loop_susp_counit X)
   o* loop_susp_unit (loops X)) @
(dpoint_eq pmap_idmap)^</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk68"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit X)
o* loop_susp_unit (loops X) == pmap_idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk69"><span class="highlight"><span class="nb">intros</span> p; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">loops X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> @
(ap (Susp_rec (point X) (point X) idmap)
   (merid p @ (merid (ispointed_loops X (point X)))^) @
 <span class="mi">1</span>) = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6a"><span class="highlight"><span class="nb">refine</span> (concat_1p _ @ (concat_p1 _ @ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">loops X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (Susp_rec (point X) (point X) idmap)
  (merid p @ (merid (ispointed_loops X (point X)))^) =
p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6b"><span class="highlight"><span class="nb">refine</span> (ap_pp (Susp_rec (point X) (point X) idmap)
                  (merid p) (merid (point (point X = point X)))^ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">loops X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (Susp_rec (point X) (point X) idmap) (merid p) @
ap (Susp_rec (point X) (point X) idmap)
  (merid (point (point X = point X)))^ = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6c"><span class="highlight"><span class="nb">refine</span> ((<span class="mi">1</span> @@ ap_V _ _) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">loops X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (Susp_rec (point X) (point X) idmap) (merid p) @
(ap (Susp_rec (point X) (point X) idmap)
   (merid (point (point X = point X))))^ = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6d"><span class="highlight"><span class="nb">refine</span> ((Susp_rec_beta_merid p
      @@ inverse2 (Susp_rec_beta_merid (point (loops X)))) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">loops X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">p @ (point (loops X))^ = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (concat_p1 _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6e"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">p</span> : loops X =&gt;
 concat_1p
   (ap (Susp_rec (point X) (point X) idmap)
      (merid p @
       (merid (ispointed_loops X (point X)))^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (Susp_rec (point X) (point X) idmap)
       (merid p @
        (merid (ispointed_loops X (point X)))^)) @
  (ap_pp (Susp_rec (point X) (point X) idmap)
     (merid p) (merid (point (point X = point X)))^ @
   ((<span class="mi">1</span> @@
     ap_V (Susp_rec (point X) (point X) idmap)
       (merid (point (point X = point X)))) @
    ((Susp_rec_beta_merid p @@
      inverse2 (Susp_rec_beta_merid (point (loops X)))) @
     concat_p1 p))))) (point (loops X)) =
dpoint_eq
  (fmap loops (loop_susp_counit X)
   o* loop_susp_unit (loops X)) @
(dpoint_eq pmap_idmap)^</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6f"><span class="highlight"><span class="nb">apply</span> moveL_pV.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(concat_1p
   (ap (Susp_rec (point X) (point X) idmap)
      (merid (point (loops X)) @
       (merid (ispointed_loops X (point X)))^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (Susp_rec (point X) (point X) idmap)
       (merid (point (loops X)) @
        (merid (ispointed_loops X (point X)))^)) @
  (ap_pp (Susp_rec (point X) (point X) idmap)
     (merid (point (loops X)))
     (merid (point (point X = point X)))^ @
   ((<span class="mi">1</span> @@
     ap_V (Susp_rec (point X) (point X) idmap)
       (merid (point (point X = point X)))) @
    ((Susp_rec_beta_merid (point (loops X)) @@
      inverse2 (Susp_rec_beta_merid (point (loops X)))) @
     concat_p1 (point (loops X))))))) @
dpoint_eq pmap_idmap =
dpoint_eq
  (fmap loops (loop_susp_counit X)
   o* loop_susp_unit (loops X))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk70"><span class="highlight"><span class="nb">destruct</span> X <span class="kr">as</span> [X x]; <span class="nb">cbn</span>; <span class="nb">unfold</span> point.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(concat_1p
   (ap (Susp_rec x x idmap)
      (merid (ispointed_loops X x) @
       (merid (ispointed_loops X x))^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (Susp_rec x x idmap)
       (merid (ispointed_loops X x) @
        (merid (ispointed_loops X x))^)) @
  (ap_pp (Susp_rec x x idmap)
     (merid (ispointed_loops X x)) (merid <span class="mi">1</span>)^ @
   ((<span class="mi">1</span> @@ ap_V (Susp_rec x x idmap) (merid <span class="mi">1</span>)) @
    ((Susp_rec_beta_merid (ispointed_loops X x) @@
      inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>))))) @ <span class="mi">1</span> =
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (Susp_rec x x idmap) p @ <span class="mi">1</span>))
  (concat_pV (merid (ispointed_loops X x))) @ <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk71"><span class="highlight"><span class="nb">apply</span> whiskerR.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">concat_1p
  (ap (Susp_rec x x idmap)
     (merid (ispointed_loops X x) @
      (merid (ispointed_loops X x))^) @ <span class="mi">1</span>) @
(concat_p1
   (ap (Susp_rec x x idmap)
      (merid (ispointed_loops X x) @
       (merid (ispointed_loops X x))^)) @
 (ap_pp (Susp_rec x x idmap)
    (merid (ispointed_loops X x)) (merid <span class="mi">1</span>)^ @
  ((<span class="mi">1</span> @@ ap_V (Susp_rec x x idmap) (merid <span class="mi">1</span>)) @
   ((Susp_rec_beta_merid (ispointed_loops X x) @@
     inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>)))) =
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (Susp_rec x x idmap) p @ <span class="mi">1</span>))
  (concat_pV (merid (ispointed_loops X x)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk72"><span class="highlight"><span class="nb">rewrite</span> (concat_pV_inverse2
               (ap (Susp_rec x x idmap) (merid <span class="mi">1</span>))
               <span class="mi">1</span> (Susp_rec_beta_merid <span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">concat_1p
  (ap (Susp_rec x x idmap)
     (merid (ispointed_loops X x) @
      (merid (ispointed_loops X x))^) @ <span class="mi">1</span>) @
(concat_p1
   (ap (Susp_rec x x idmap)
      (merid (ispointed_loops X x) @
       (merid (ispointed_loops X x))^)) @
 (ap_pp (Susp_rec x x idmap)
    (merid (ispointed_loops X x)) (merid <span class="mi">1</span>)^ @
  ((<span class="mi">1</span> @@ ap_V (Susp_rec x x idmap) (merid <span class="mi">1</span>)) @
   concat_pV (ap (Susp_rec x x idmap) (merid <span class="mi">1</span>))))) =
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (Susp_rec x x idmap) p @ <span class="mi">1</span>))
  (concat_pV (merid (ispointed_loops X x)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk73"><span class="highlight"><span class="nb">rewrite</span> (ap_pp_concat_pV (Susp_rec x x idmap) (merid <span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">concat_1p
  (ap (Susp_rec x x idmap)
     (merid (ispointed_loops X x) @
      (merid (ispointed_loops X x))^) @ <span class="mi">1</span>) @
(concat_p1
   (ap (Susp_rec x x idmap)
      (merid (ispointed_loops X x) @
       (merid (ispointed_loops X x))^)) @
 ap (ap (Susp_rec x x idmap)) (concat_pV (merid <span class="mi">1</span>))) =
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (Susp_rec x x idmap) p @ <span class="mi">1</span>))
  (concat_pV (merid (ispointed_loops X x)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk74"><span class="highlight"><span class="nb">rewrite</span> ap_compose, (ap_compose _ (<span class="kr">fun</span> <span class="nv">p</span> =&gt; p @ <span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">concat_1p
  (ap (Susp_rec x x idmap)
     (merid (ispointed_loops X x) @
      (merid (ispointed_loops X x))^) @ <span class="mi">1</span>) @
(concat_p1
   (ap (Susp_rec x x idmap)
      (merid (ispointed_loops X x) @
       (merid (ispointed_loops X x))^)) @
 ap (ap (Susp_rec x x idmap)) (concat_pV (merid <span class="mi">1</span>))) =
ap (concat <span class="mi">1</span>)
  (ap
     (<span class="kr">fun</span> <span class="nv">p</span> : Susp_rec x x idmap ispointed_susp = x =&gt;
      p @ <span class="mi">1</span>)
     (ap (ap (Susp_rec x x idmap))
        (concat_pV (merid (ispointed_loops X x)))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk75"><span class="highlight"><span class="nb">rewrite</span> concat_1p_1; <span class="nb">apply</span> ap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPointed X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">concat_p1
  (ap (Susp_rec x x idmap)
     (merid (ispointed_loops X x) @
      (merid (ispointed_loops X x))^)) @
ap (ap (Susp_rec x x idmap)) (concat_pV (merid <span class="mi">1</span>)) =
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : Susp_rec x x idmap ispointed_susp = x =&gt;
   p @ <span class="mi">1</span>)
  (ap (ap (Susp_rec x x idmap))
     (concat_pV (merid (ispointed_loops X x))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> concat_p1_1.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk76"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_triangle2</span> (<span class="nv">X</span> : pType)
  : loop_susp_counit (psusp X) o* fmap psusp (loop_susp_unit X)
  ==* pmap_idmap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_counit (psusp X)
o* fmap psusp (loop_susp_unit X) ==* pmap_idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk77"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_counit (psusp X)
o* fmap psusp (loop_susp_unit X) ==* pmap_idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk78"><span class="highlight"><span class="nb">simple refine</span> (Build_pHomotopy _ _);
  [ <span class="nb">simple refine</span> (Susp_ind _ _ _ _) | ]; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Susp_rec ispointed_susp ispointed_susp idmap
  (functor_susp
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid (point X))^) South) =
South</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk79"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   Susp_rec ispointed_susp ispointed_susp idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid x0 @ (merid (point X))^)
        y) = y) (merid x) <span class="mi">1</span> = <span class="nl">?Goal</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7a"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Susp_rec ispointed_susp ispointed_susp idmap
  (functor_susp
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid (point X))^) South) =
South</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (merid (point X)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7b"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   Susp_rec ispointed_susp ispointed_susp idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid x0 @ (merid (point X))^)
        y) = y) (merid x) <span class="mi">1</span> = merid (point X)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7c"><span class="highlight"><span class="nb">intros</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   Susp_rec ispointed_susp ispointed_susp idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid (point X))^) y) =
   y) (merid x) <span class="mi">1</span> = merid (point X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7d"><span class="highlight"><span class="nb">rewrite</span> transport_paths_FlFr, ap_idmap, ap_compose.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((ap (Susp_rec ispointed_susp ispointed_susp idmap)
    (ap
       (functor_susp
          (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid (point X))^))
       (merid x)))^ @ <span class="mi">1</span>) @ merid x = merid (point X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7e"><span class="highlight"><span class="nb">rewrite</span> Susp_rec_beta_merid.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((ap (Susp_rec ispointed_susp ispointed_susp idmap)
    (merid (merid x @ (merid (point X))^)))^ @ <span class="mi">1</span>) @
merid x = merid (point X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7f"><span class="highlight"><span class="nb">apply</span> moveR_pM; <span class="nb">rewrite</span> concat_p1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ap (Susp_rec ispointed_susp ispointed_susp idmap)
   (merid (merid x @ (merid (point X))^)))^ =
merid (point X) @ (merid x)^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk80"><span class="highlight"><span class="nb">refine</span> (inverse2 (Susp_rec_beta_merid _) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(merid x @ (merid (point X))^)^ =
merid (point X) @ (merid x)^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> inv_pp, inv_V; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Now we can finally construct the adjunction equivalence. *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk81"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_adjoint</span> `{Funext} (A B : pType)
  : (psusp A -&gt;* B) &lt;~&gt; (A -&gt;* loops B).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(psusp A -&gt;* B) &lt;~&gt; (A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk82"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(psusp A -&gt;* B) &lt;~&gt; (A -&gt;* loops B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk83"><span class="highlight"><span class="nb">refine</span> (equiv_adjointify
            (<span class="kr">fun</span> <span class="nv">f</span> =&gt; fmap loops f o* loop_susp_unit A)
            (<span class="kr">fun</span> <span class="nv">g</span> =&gt; loop_susp_counit B o* fmap psusp g) _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A -&gt;* loops B =&gt;
 fmap loops (loop_susp_counit B o* fmap psusp x)
 o* loop_susp_unit A) == idmap</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk84" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="psusp-v-chk84"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : psusp A $-&gt; B =&gt;
 loop_susp_counit B
 o* fmap psusp (fmap loops x o* loop_susp_unit A)) ==
idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk85"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A -&gt;* loops B =&gt;
 fmap loops (loop_susp_counit B o* fmap psusp x)
 o* loop_susp_unit A) == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk86"><span class="highlight"><span class="nb">intros</span> g.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit B o* fmap psusp g)
o* loop_susp_unit A = g</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk87"><span class="highlight"><span class="nb">apply</span> path_pforall.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit B o* fmap psusp g)
o* loop_susp_unit A ==* g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk88"><span class="highlight"><span class="nb">refine</span> (pmap_prewhisker _ (fmap_comp loops _ _) @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit B) $o
fmap loops (fmap psusp g) o* loop_susp_unit A ==* g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk89"><span class="highlight"><span class="nb">refine</span> (pmap_compose_assoc _ _ _ @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit B)
o* (fmap loops (fmap psusp g) o* loop_susp_unit A) ==*
g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8a"><span class="highlight"><span class="nb">refine</span> (pmap_postwhisker _ (loop_susp_unit_natural g)^* @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit B)
o* (loop_susp_unit (loops B) o* g) ==* g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8b"><span class="highlight"><span class="nb">refine</span> ((pmap_compose_assoc _ _ _)^* @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (loop_susp_counit B)
o* loop_susp_unit (loops B) o* g ==* g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8c"><span class="highlight"><span class="nb">refine</span> (pmap_prewhisker g (loop_susp_triangle1 B) @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pmap_idmap o* g ==* g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> pmap_postcompose_idmap.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8d"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : psusp A $-&gt; B =&gt;
 loop_susp_counit B
 o* fmap psusp (fmap loops x o* loop_susp_unit A)) ==
idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8e"><span class="highlight"><span class="nb">intros</span> f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A $-&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_counit B
o* fmap psusp (fmap loops f o* loop_susp_unit A) = f</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8f"><span class="highlight"><span class="nb">apply</span> path_pforall.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A $-&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_counit B
o* fmap psusp (fmap loops f o* loop_susp_unit A) ==* f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk90"><span class="highlight"><span class="nb">refine</span> (pmap_postwhisker _ (fmap_comp psusp _ _) @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A $-&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_counit B
o* (fmap psusp (fmap loops f) $o
    fmap psusp (loop_susp_unit A)) ==* f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk91"><span class="highlight"><span class="nb">refine</span> ((pmap_compose_assoc _ _ _)^* @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A $-&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_counit B o* fmap psusp (fmap loops f)
o* fmap psusp (loop_susp_unit A) ==* f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk92"><span class="highlight"><span class="nb">refine</span> (pmap_prewhisker _ (loop_susp_counit_natural f)^* @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A $-&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f o* loop_susp_counit (psusp A)
o* fmap psusp (loop_susp_unit A) ==* f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk93"><span class="highlight"><span class="nb">refine</span> (pmap_compose_assoc _ _ _ @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A $-&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f
o* (loop_susp_counit (psusp A)
    o* fmap psusp (loop_susp_unit A)) ==* f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk94"><span class="highlight"><span class="nb">refine</span> (pmap_postwhisker f (loop_susp_triangle2 A) @* _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A $-&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f o* pmap_idmap ==* f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> pmap_precompose_idmap.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** And its naturality is easy. *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk95"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_adjoint_nat_r</span> `{Funext} (A B B&#39; : pType)
  (f : psusp A -&gt;* B) (g : B -&gt;* B&#39;) : loop_susp_adjoint A B&#39; (g o* f)
  ==* fmap loops g o* loop_susp_adjoint A B f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A -&gt;* B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt;* B&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_adjoint A B&#39; (g o* f) ==*
fmap loops g o* loop_susp_adjoint A B f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk96"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A -&gt;* B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt;* B&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_adjoint A B&#39; (g o* f) ==*
fmap loops g o* loop_susp_adjoint A B f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk97"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A -&gt;* B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt;* B&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Build_pMap (loops (psusp A)) (loops B&#39;)
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   (ap g (point_eq f) @ point_eq g)^ @
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; g (f x)) p @
    (ap g (point_eq f) @ point_eq g)))
  (whiskerL (ap g (point_eq f) @ point_eq g)^
     (concat_1p (ap g (point_eq f) @ point_eq g)) @
   concat_Vp (ap g (point_eq f) @ point_eq g))
o* loop_susp_unit A ==*
Build_pMap (loops B) (loops B&#39;)
  (<span class="kr">fun</span> <span class="nv">p</span> : point B = point B =&gt;
   (point_eq g)^ @ (ap g p @ point_eq g))
  (whiskerL (point_eq g)^ (concat_1p (point_eq g)) @
   concat_Vp (point_eq g))
o* (Build_pMap (loops (psusp A)) (loops B)
      (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
       (point_eq f)^ @ (ap f p @ point_eq f))
      (whiskerL (point_eq f)^ (concat_1p (point_eq f)) @
       concat_Vp (point_eq f)) o* loop_susp_unit A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk98"><span class="highlight"><span class="nb">refine</span> (_ @* pmap_compose_assoc _ _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A -&gt;* B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt;* B&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Build_pMap (loops (psusp A)) (loops B&#39;)
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   (ap g (point_eq f) @ point_eq g)^ @
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; g (f x)) p @
    (ap g (point_eq f) @ point_eq g)))
  (whiskerL (ap g (point_eq f) @ point_eq g)^
     (concat_1p (ap g (point_eq f) @ point_eq g)) @
   concat_Vp (ap g (point_eq f) @ point_eq g))
o* loop_susp_unit A ==*
Build_pMap (loops B) (loops B&#39;)
  (<span class="kr">fun</span> <span class="nv">p</span> : point B = point B =&gt;
   (point_eq g)^ @ (ap g p @ point_eq g))
  (whiskerL (point_eq g)^ (concat_1p (point_eq g)) @
   concat_Vp (point_eq g))
o* Build_pMap (loops (psusp A)) (loops B)
     (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
      (point_eq f)^ @ (ap f p @ point_eq f))
     (whiskerL (point_eq f)^ (concat_1p (point_eq f)) @
      concat_Vp (point_eq f)) o* loop_susp_unit A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk99"><span class="highlight"><span class="nb">apply</span> pmap_prewhisker.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">psusp A -&gt;* B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt;* B&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Build_pMap (loops (psusp A)) (loops B&#39;)
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   (ap g (point_eq f) @ point_eq g)^ @
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; g (f x)) p @
    (ap g (point_eq f) @ point_eq g)))
  (whiskerL (ap g (point_eq f) @ point_eq g)^
     (concat_1p (ap g (point_eq f) @ point_eq g)) @
   concat_Vp (ap g (point_eq f) @ point_eq g)) ==*
Build_pMap (loops B) (loops B&#39;)
  (<span class="kr">fun</span> <span class="nv">p</span> : point B = point B =&gt;
   (point_eq g)^ @ (ap g p @ point_eq g))
  (whiskerL (point_eq g)^ (concat_1p (point_eq g)) @
   concat_Vp (point_eq g))
o* Build_pMap (loops (psusp A)) (loops B)
     (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
      (point_eq f)^ @ (ap f p @ point_eq f))
     (whiskerL (point_eq f)^ (concat_1p (point_eq f)) @
      concat_Vp (point_eq f))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (fmap_comp loops f g).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9a"><span class="highlight"><span class="kn">Definition</span> <span class="nf">loop_susp_adjoint_nat_l</span> `{Funext} (A A&#39; B : pType)
  (f : A -&gt;* loops B) (g : A&#39; -&gt;* A) : (loop_susp_adjoint A&#39; B)^-<span class="mi">1</span> (f o* g)
  ==* (loop_susp_adjoint A B)^-<span class="mi">1</span> f o* fmap psusp g.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, A', B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A&#39; -&gt;* A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(loop_susp_adjoint A&#39; B)^-<span class="mi">1</span> (f o* g) ==*
(loop_susp_adjoint A B)^-<span class="mi">1</span> f o* fmap psusp g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, A', B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A&#39; -&gt;* A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(loop_susp_adjoint A&#39; B)^-<span class="mi">1</span> (f o* g) ==*
(loop_susp_adjoint A B)^-<span class="mi">1</span> f o* fmap psusp g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9c"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, A', B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A&#39; -&gt;* A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_counit B
o* Build_pMap (psusp A&#39;) (psusp (loops B))
     (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; f (g x))) <span class="mi">1</span> ==*
loop_susp_counit B
o* Build_pMap (psusp A) (psusp (loops B))
     (functor_susp f) <span class="mi">1</span>
o* Build_pMap (psusp A&#39;) (psusp A) (functor_susp g) <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9d"><span class="highlight"><span class="nb">refine</span> (_ @* (pmap_compose_assoc _ _ _)^*).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, A', B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A&#39; -&gt;* A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loop_susp_counit B
o* Build_pMap (psusp A&#39;) (psusp (loops B))
     (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; f (g x))) <span class="mi">1</span> ==*
loop_susp_counit B
o* (Build_pMap (psusp A) (psusp (loops B))
      (functor_susp f) <span class="mi">1</span>
    o* Build_pMap (psusp A&#39;) (psusp A)
         (functor_susp g) <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9e"><span class="highlight"><span class="nb">apply</span> pmap_postwhisker.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, A', B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt;* loops B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A&#39; -&gt;* A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Build_pMap (psusp A&#39;) (psusp (loops B))
  (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; f (g x))) <span class="mi">1</span> ==*
Build_pMap (psusp A) (psusp (loops B))
  (functor_susp f) <span class="mi">1</span>
o* Build_pMap (psusp A&#39;) (psusp A) (functor_susp g) <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (fmap_comp psusp g f).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9f"><span class="highlight"><span class="kn">Instance</span> <span class="nf">is1natural_loop_susp_adjoint_r</span> `{Funext} (A : pType)
  : Is1Natural (opyon (psusp A)) (opyon A o loops)
      (loop_susp_adjoint A).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Is1Natural (opyon (psusp A)) (opyon A o loops)
  (<span class="kr">fun</span> <span class="nv">B</span> : pType =&gt; loop_susp_adjoint A B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka0"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Is1Natural (opyon (psusp A)) (opyon A o loops)
  (<span class="kr">fun</span> <span class="nv">B</span> : pType =&gt; loop_susp_adjoint A B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka1"><span class="highlight"><span class="nb">intros</span> B B&#39; g f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; B&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">opyon (psusp A) B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(loop_susp_adjoint A B&#39; $o fmap (opyon (psusp A)) g) f =
(fmap (opyon A o loops) g $o loop_susp_adjoint A B) f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka2"><span class="highlight"><span class="nb">refine</span> ( _ @ cat_assoc_strong _ _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; B&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">opyon (psusp A) B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(loop_susp_adjoint A B&#39; $o fmap (opyon (psusp A)) g) f =
fmap loops g $o fmap loops f $o loop_susp_unit A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka3"><span class="highlight"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x o* loop_susp_unit A) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; B&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">opyon (psusp A) B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (fmap (opyon (psusp A)) g f) =
fmap loops g $o fmap loops f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka4"><span class="highlight"><span class="nb">apply</span> path_pforall.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; B&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">opyon (psusp A) B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap loops (fmap (opyon (psusp A)) g f) ==*
fmap loops g $o fmap loops f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">rapply (fmap_comp loops).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka5"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">natequiv_loop_susp_adjoint_r</span> `{Funext} (A : pType)
  : NatEquiv (opyon (psusp A)) (opyon A o loops).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">NatEquiv (opyon (psusp A)) (opyon A o loops)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">NatEquiv (opyon (psusp A)) (opyon A o loops)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">rapply Build_NatEquiv.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre>
</div>
</div></body>
</html>
